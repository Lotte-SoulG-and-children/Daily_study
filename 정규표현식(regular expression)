SOUL-G and Children 6/10~6/27

<aside>
💡 ***[왜 정규표현식(이하 정규식)을 선택했나?]**
정규식은 언어를 넘어 다양한 시스템과 운영체제에서 사용할 수 있어 한번 제대로 배워둔다면 다방면에서 활용할 수 있다는 장점이 있다*

</aside>

### **[정규식이란 무엇인가?]**

**정규식은 언어다!**

특정한 규칙을 가진 문자열의 집합을 사용하는데 표현하는 형식언어

### [정규식 활용]

- **패턴 검사**: 패턴과 부합하는지 여부 검증 - 이메일 검사
Pattern.matches("^[a-zA-Z0-9_!#$%&'*+/=?`{|}~^.-]+@[a-zA-Z0-9.-]+$", inputStr);
- **패턴 추출**: 패턴과 부합하는 문자열 토큰 추출 - 데이터 파싱
    
    Pattern p = Pattern.compile(regex);
    Matcher m = p.matcher(input);
    
    **return** m.matches();
    
- **패턴 치환**: 패턴과 부합하는 문자열 토큰 치환 - replace
Pattern.compile(regex).matcher(**this**).replaceAll(replacement);

### 예시

- **사용자 입력 유효성 검증**: 이메일 주소, URL, 전화번호, 주민등록번호
- **패턴에 기반한 감지 및 치환**: SQL Injection 탐지, HTML 태그 및 (악성)스크립트 제거

알파벳 검증

```java
public static boolean IsAlpha(String inputStr){
        for(int i=0; i<inputStr.length();i++){
            if(!(inputStr.charAt(i)>='A'&&inputStr.charAt(i)<='Z')||(inputStr.charAt(i)>='a'&&inputStr.charAt(i)<='z')){
                return false;
            }
        }
        return true;
    }
```

```java
public static boolean IsAlphaRegex(String inputStr){
        return Pattern.matches("^[a-zA-Z]*$",inputStr);
    }
}
```

이메일 검증

```java
public static boolean IsValidEmailAddress(String inputStr) {
        if ((inputStr.indexOf("@") != -1) && (inputStr.indexOf(".") != -1)) {
            String[] temp = inputStr.split("@");
            if (temp[0] != null) {
                //대충 @ 이전 문자열이 맞는 문자열인지 확인하는 코드
            }else return false;
            if(temp[1] != null){
                //대충 @ 이후 문자열이 맞는 문자열인지 확인하는 코드
            }
        }

        return false;
    }
```

```java
public static boolean IsValidEmailAddressRegex(String inputStr)
    {
        return Pattern.matches("^[a-zA-Z0-9_!#$%&'*+/=?`{|}~^.-]+@[a-zA-Z0-9.-]+$", inputStr);
    }
```

### **1. 매칭될 문자를 지정하거나, 제외하는 방법입니다.**

| 정규식 | 설명 |
| --- | --- |
| [abc] | a, b, c중 하나이면 일치 합니다. |
| [^abc] | a, b, c를 제외한 다른 글자 이면 일치합니다. |
| [a-zA-Z] | a 부터 z까지의 소문자 알파벳 이거나 A 부터 Z까지의 대문자 알파벳 중의 하나라면 일치합니다.(범위) |
| [a-d[m-p]] | a 부터 d까지, 또는 m 부터 p까지 중에 하나와 일치합니다: [a-dm-p] (합집합) |
| [a-z&&[def]] | d, e, f 중의 하나와 일치합니다. (교집합) |
| [a-z&&[^bc]] | b와 c를 제외한 a 부터 z까지 중의 하나와 일치합니다: [ad-z] (차집합) |
| [a-z&&[^m-p]] | m부터 p 까지를 제외한, a 부터 z까지 중의 하나와 일치합니다: [a-lq-z] (차집합) |

### **2. 미리 정의된 문자를 지정하는 방법입니다.**

| 정규식 | 설명 |
| --- | --- |
| . | 임의의 문자 (라인 종결자와 일치할 수도 하지 않을 수도 있음) |
| \d | 숫자 문자: [0-9] |
| \D | 숫자 문자가 아닌것: [^0-9] |
| \s | 화이트 스페이스 문자: [ \t\n\x0B\f\r] |
| \S | 화이트 스페이스 문자가 아닌것: [^\s] |
| \w | 알파벳 단어 문자(word 문자): [a-zA-Z_0-9] |
| \W | 알파벳 단어 문자가 아닌것: [^\w] |

### **3. 수량 매칭**

| Greedy | Reluctant | Possessive | 의미 |
| --- | --- | --- | --- |
| X? | X?? | X?+ | X가 없거나 한번 나옴 |
| X* | X*? | X*+ | X가 없거나 한번 이상 나옴 |
| X+ | X+? | X++ | X가 한번 또는 여러번 나옴 |
| X{n} | X{n}? | X{n}+ | X가 정확히 n번 나옴 |
| X{n,} | X{n,}? | X{n,}+ | X가 n번 이상 나옴 |
| X{n,m} | X{n,m}? | X{n,m}+ | X가 n이상 m이하로 나옴 |

패턴이 나오는 횟수를 지정할 수 있습니다.

```
-Greedy : 매칭을 위해서 입력된 문자열 전체를 읽어서 확인하고 뒤에서 한자씩 빼면서 끝까지 확인합니다.
Reluctant : 입력된 문자열에서 한글자씩 확인해 나갑니다. 마지막에 확인하는 것은 전체 문자열 입니다.
Possessive : 입력된 전체 문자열을 확인합니다. Greedy와 달리 뒤에서 빼면서 확인하지 않습니다.(geedy와 비슷하지만 Backtraking 진행하지 않는다.)
```

### 4. 정규식 그룹 캡쳐

```

Pattern API에 설명된 대로, 그룹 캡쳐는 열린 괄호를 왼쪽에서 오른쪽으로 세어서 숫자를 붙입니다. 예로, 표현식 ((A)(B(C))) 는 다음과 같은 네 개의 그룹이 있습니다.
1: ((A)(B(C)))
2: (A)
3: (B(C))
4: (C)
이 그룹 번호는 역참조로 그룹에 접근하는데 사용될 수 있습니다.
```

### **5. 그룹 역참조**

```
문자열내에서 중복된 알파벳으로된 단어를 찾습니다. \\1 로 번호가 붙은 부분이 1번 그룹을 역참조하는 부분입니다.
```

### **6. 경계조건 판별 조건**

| 정규식 | 설명 |
| --- | --- |
| ^ | 행의 시작 |
| $ | 행의 끝 |
| \b | 단어 경계 |
| \B | 단어가 아닌것의 경계 |
| \A | 입력의 시작 부분 |
| \G | 이전 매치의 끝 |
| \Z | 입력의 끝이지만 종결자가 있는 경우 |
| \z | 입력의 끝 |

행의 시작 끝, 단어 경계 등을 판별합니다.

### **7. 패턴 매칭에서 플래그 사용**

| 플래그 | 동등한 내장 표현 | 설명 |
| --- | --- | --- |
| Pattern.CANON_EQ | None | 표준화된 매칭 모드를 활성화합니다. 이 모드가 켜지면 a를 나타내는 유니코드 "\u00E5"와 a와 상단고리 유니코드를 쓴 "a\u030A"를 같다고 매칭합니다. |
| Pattern.CASE_INSENSITIVE | (?i) | 대소문자를 구분하지 않습니다. |
| Pattern.COMMENTS | (?x) | 공백과 주석이 무시됩니다. 주석은 #부터 그 행 끝까지 입니다. |
| Pattern.MULTILINE | (?m) | 다중행 모드를 사용여 모든 ^와 $가 인식됩니다. 기본값은 입력값 전체를 하나의 시작과 끝으로 인식합니다. |
| Pattern.DOTALL | (?s) | .가 개행문자 까지 포함하는 모든 문자로 매칭됩니다. |
| Pattern.LITERAL | None | 입력의 메타문자와 이스케이프된 문자를 일반 문자로 취급합니다. CASE_INSENSITIVE와 UNICODE_CASE는 기능이 유지됩니다. |
| Pattern.UNICODE_CASE | (?u) | 이 모드가 활성화 되면 대소문자 매칭이 유니코드 표준을 따릅니다. 기본은 US-ASCII 문자 집합을 따릅니다. |
| Pattern.UNIX_LINES | (?d) | ^와 $를 처리시 UNIX 개행을 사용합니다. |

패턴이 매치되는 방법에 영향을 미치는 플래그를 제공합니다

여러개의 플래그를 사용할 때는 | 연산자로 연결합니다.

자주 사용하는 표현

| 정규 표현식 | 설명 |
| --- | --- |
| ^[0-9]*$ | 숫자 |
| ^[a-zA-Z]*$ | 영문자 |
| ^[가-힣]*$ | 한글 |
| \\w+@\\w+\\.\\w+(\\.\\w+)? | E-Mail |
| ^\d{2,3}-\d{3,4}-\d{4}$ | 전화번호 |
| ^01(?:0|1|[6-9])-(?:\d{3}|\d{4})-\d{4}$ | 휴대전화번호 |
| \d{6} \- [1-4]\d{6} | 주민등록번호 |
| ^\d{3}-\d{2}$ | 우편번호 |

```java
Line 394 : [21:44:07 Oct 12 Fri] @0x3924004E|JVM| Free Memory: Heap [ 2368340/ 6291456], Native[ 7299824/32505856]

((?:\d{2})(?:\:\d{2}){2}).*?\[\s(\d+).*?\[\s(\d+)
---------------------------------------------------
(                   # 첫번째 그룹을 캡쳐
(?:\d{2})           # 숫자 두 개가 연속으로 나오고
(?:                 # 캡쳐안되는 그룹으로 묶은,
\:\d{2}             # :45 같은 : 뒤에 숫자 두 개가 오는 패턴이
){2}                # 두개 더 붙어서 12:34:56 패턴을 완성
)                   # 이게 첫번째 그룹
.*?\[\s             # "[ " 을 만날 때까지 앞으로 나가서
(\d+)               # 연속된 숫자만 취한다. 이게 두 번째 그룹
.*?\[\s(\d+)        # 같은 패턴을 한 번 더 써서 세 번째 그룹
```

### 정규식의 성능

정규식 작동 방식은 “백트래킹” 방식으로 왼쪽→오른쪽으로 탐색을 진행하며 패턴과 매칭되지 않으면 재탐색

예시 )

inputString = “scaredd”

regex = “sc(ored|ared|oring|)x”

sc 매칭 → ored 매칭 실패 → ared 매칭 → x매칭 실패 → sc 매칭 실패 

### 정규식의 최적화

1. 한번 이상 사용한다면 Pattern.compile 활용

```java
{
	Pattern.compile("ABC").matcher(s).matches();
}
{
	s.contain("ABC");
}
```

```java
private static final Pattern pattern = Pattern.compile("ABC");

{
	pattern.matcher(s).matches();
}
```

여러번 참조된다면 컴파일을 시켜둠으로 불필요한 성능 낭비 최소화

1. (X|Y|Z) 와 같은 alternation regex 사용시 자주 등장하는 패턴을 앞에 배치

```java
alternation regex은 매 문자열 마다 모든 경우를 확인하기 때문에 속도가 느린편이다.
따라서 단순 검사의 경우 String.indexOf()가 더 효과적일 수 있다.
최적화를 위해 자주 등장하는 패턴을 앞에 배치하면 그나마 속도를 향상 시킬 수 있다.
```

1. 캡처링 그룹의 사용은 약간의 성는 저하를 가져 온다. (A(BC))

```java
따라서 non-capturing group 을 사용해야 한다 (?:A(?:BC))
```

1. Java 엔진에 맞춘 코드를 짠다.

```
예를 들어 regex 가 input string 중 반드시 포함된다면 engine 은 그 string 을 먼저 search 한다.또한 전체 expression 이 절대 매칭될 수 없다거나 하면, 해당 string 에 대한 regex 을 실제 check 하지 않고 fail 을 뱉어낸다.

-engine 이 input string 의 length 를 regex 가 기대하는 length 기준으로 체크하는 것이다.예를 들어 \d{100} 이라고 되어있는데, input string 이 100 length 가 안 된다면 engine 은 regex 를 돌려보지 않고 바로 fail 을 뱉는다.

-복잡한 regex 를 사용할 때면 regex engine 이 최적화를 할 수 있는 방향으로 작성하는 것이 좋다.예를 들어 필수 string 을 grouping 이나 alternation 에 숨기지 않는 것이 좋다.그리고 가능하다면 길이를 명시해주는 것이 좋다.
```

1. Optimizing greedy and reluctant quantifiers

```java
* 나 + 와 같은 greedy quantifier 는 가능한한 많은 char 가 매칭되는 방향으로 match 를 찾는다.
심지어 최대한 매칭을 한 후 나머지 regex 의 매칭을 할 char 가 없어도 말이다.
따라서 greedy quantifier 의 경우 backtracking 을 하게 되고, 
overall match 가 찾아지거나 fail 이 될때까지 backtracking 을 계속한다.

reluctant(or lazy) quantifier 는 가능한한 적은 char 가 매칭되는 방향으로 match 를 찾는다.
만약 찾고자 하는 char 가 string 의 마지막부에 있다면 greedy quantifier 를 사용하는 것이 좋다. 
(ex) .*a)만약 찾고자 하는 것이 string 의 초반부에 있다면 lazy quantifier 를 사용하는 것이 좋다. 
(ex) .*?a)

regex 를 더 정밀하게 쓰는 것이 좋다.
예를 들어 두개의 a 사이의 char 들을 구하는 것이라면 a(.*)a 대신 a([^a]*)a 를 사용하는 것이 좋다.

```

1. Possessive quantifiers and independent grouping

```
Possessive quanifier 와 independent grouping 은 regex 를 최적화하는데 아주 유용한 녀석들이다.
가능한한 이 녀석을 사용하는 것이 엄청난 성능 향상을 가져오곤 한다. 
( backtracking 하지 않지 않는다. )
Possessive quantifier 는 추가 + 사인으로 마킹된다. 예를 들어 X?+, X*+, X++ 이다.independent grouping 은 (?>X) 이다. 

두개의 operator 는 모두 backtracking 동작을 disable 시킨다.backtracking 을 disable 시키기 때문에 regex 를 fail 로 몰고가기도 하기 때문에, 정확히 이해하고 써야 한다.
```

1. A note about the StackOverflowError

```
가끔 Pattern class 가 StackOverflowError 를 던지곤 한다.
이것은 Java 1.4 부터 있어온 버그이며, won't fix 로 결정난 상태이다.
이 에러는 Pattern 클래스가 regex 를 compile 하여 match 를 수행할 때 실행될 small program 으로 만들 때 발생한다.
이 small program 은 보통 recursive 하게 발생하며, 너무 많은 recursive 가 발생하면 이 에러가 발생하는 것이다.그리고 이것이 발생하는 경우는 주로 alternation 을 사용한 경우이다.
만약 이 에러를 마딱뜨린다면, regex 를 다시 쓰거나, 여러개의 sub-expression 을 나누어 실행하도록 해야 한다.sub-expression 을 나누어 실행하는 것은 성능 저하를 일으킬 수 있다.
```

### 참고 사이트

[정규식 시각화 사이트](https://regexper.com/#%5E%5Ba-zA-Z0-9_!%23%24%25%26'*%2B%2F%3D%3F%60%7B%7C%7D~%5E.-%5D%2B%40%5Ba-zA-Z0-9.-%5D%2B%24)

정규식 시각화 사이트

[regex101: build, test, and debug regex](http://regex101.com/)

무료 정규식 검증 사이트

정규식 생성 프로그램은 유료로 존재

### 참조

> [https://offbyone.tistory.com/400](https://offbyone.tistory.com/400)
[https://aroundck.tistory.com/6506](https://aroundck.tistory.com/6506)
> 

[연습장](https://www.notion.so/025b372ec83346b8829b2b256bd76ef7)
